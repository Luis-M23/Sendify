
-- NOTIFICACION TRACKING

CREATE OR REPLACE FUNCTION public.fn_notificacion_tracking()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.notificaciones (id_usuario, tipo, comentario, leido)
    VALUES (
      NEW.id_usuario,
      'tracking',
      CONCAT('Nuevo tracking ', NEW.codigo, ' disponible'),
      FALSE
    );

  ELSIF TG_OP = 'UPDATE' THEN
    INSERT INTO public.notificaciones (id_usuario, tipo, comentario, leido)
    VALUES (
      NEW.id_usuario,
      'tracking',
      CONCAT('Nuevo estado del paquete ', NEW.codigo, ' disponible'),
      FALSE
    );
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS notificacion_tracking ON public.paquetes;

CREATE TRIGGER notificacion_tracking
AFTER INSERT OR UPDATE ON public.paquetes
FOR EACH ROW
EXECUTE FUNCTION public.fn_notificacion_tracking();

-- NOTIFICACION PROMO

CREATE OR REPLACE FUNCTION public.fn_notificacion_promo()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.notificaciones (id_usuario, tipo, comentario, leido)
  SELECT
    u.id,                  
    'promo',
    CONCAT('Nueva promoción disponible: ', NEW.codigo),
    FALSE                          
  FROM auth.users u;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS notificacion_promo ON public.promociones;

CREATE TRIGGER notificacion_promo
AFTER INSERT ON public.promociones
FOR EACH ROW
EXECUTE FUNCTION public.fn_notificacion_promo();

-- NOTIFICACION CASILLERO

CREATE OR REPLACE FUNCTION public.fn_notificacion_casillero()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.notificaciones (id_usuario, tipo, comentario, leido)
    SELECT
      u.id,
      'info',
      CONCAT('Contamos con un nuevo casillero: ', NEW.codigo),
      FALSE
    FROM auth.users u;

  ELSIF TG_OP = 'UPDATE' THEN
    INSERT INTO public.notificaciones (id_usuario, tipo, comentario, leido)
    SELECT
      u.id,
      'info',
      CONCAT('Se ha actualizado el casillero ', NEW.codigo),
      FALSE
    FROM auth.users u;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS notificacion_casillero ON public.casilleros;

CREATE TRIGGER notificacion_casillero
AFTER INSERT OR UPDATE ON public.casilleros
FOR EACH ROW
EXECUTE FUNCTION public.fn_notificacion_casillero();

-- NOTIFICACION DIRECCION

CREATE OR REPLACE FUNCTION public.fn_notificacion_direccion()
RETURNS TRIGGER AS $$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO public.notificaciones (id_usuario, tipo, comentario, leido)
    SELECT
      u.id,
      'info',
      'Se ha creado una nueva dirección disponible',
      FALSE
    FROM auth.users u;

  ELSIF TG_OP = 'UPDATE' THEN
    INSERT INTO public.notificaciones (id_usuario, tipo, comentario, leido)
    SELECT
      u.id,
      'info',
      'Se ha actualizado una dirección existente',
      FALSE
    FROM auth.users u;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS notificacion_direccion ON public.direcciones;

CREATE TRIGGER notificacion_direccion
AFTER INSERT OR UPDATE ON public.direcciones
FOR EACH ROW
EXECUTE FUNCTION public.fn_notificacion_direccion();

-- AUTOINCREMENT COMPRAS

CREATE OR REPLACE FUNCTION public.fn_incrementar_compras_realizadas()
RETURNS TRIGGER AS $$
BEGIN
  UPDATE public.usuario_metadata
  SET compras_realizadas = COALESCE(compras_realizadas, 0) + 1
  WHERE id_usuario = NEW.id_usuario;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS incrementar_compras_realizadas ON public.paquetes;

CREATE TRIGGER incrementar_compras_realizadas
AFTER INSERT ON public.paquetes
FOR EACH ROW
EXECUTE FUNCTION public.fn_incrementar_compras_realizadas();

-- AUTH USER A USUARIO METADATA

CREATE OR REPLACE FUNCTION public.fn_sync_user_metadata()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.usuario_metadata (id_usuario, nombre_completo, correo)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'nombre', ''),
    NEW.email
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS trg_sync_user_metadata ON auth.users;

CREATE TRIGGER trg_sync_user_metadata
AFTER INSERT ON auth.users
FOR EACH ROW
EXECUTE FUNCTION public.fn_sync_user_metadata();

-- CONTEO POR CASILLEROS
CREATE OR REPLACE VIEW conteo_paquetes_por_casillero AS
SELECT 
  p.id_casillero,
  c.codigo AS codigo_casillero,
  COUNT(*) FILTER (WHERE p.activo = true) AS activos,
  COUNT(*) FILTER (WHERE p.activo = false) AS inactivos
FROM public.paquetes p
JOIN public.casilleros c ON p.id_casillero = c.id
GROUP BY p.id_casillero, c.codigo;


-- CANTIDAD DE ACTIVOS E INACTIVOS
CREATE OR REPLACE VIEW total_paquetes_activos_inactivos AS
SELECT 
  COUNT(*) FILTER (WHERE activo = true) AS activos,
  COUNT(*) FILTER (WHERE activo = false) AS inactivos
FROM public.paquetes;

-- PAQUETES POR MES
CREATE OR REPLACE VIEW paquetes_por_mes AS
SELECT
  DATE_TRUNC('month', created_at) AS mes,
  COUNT(*) AS cantidad
FROM public.paquetes
GROUP BY mes
ORDER BY mes;

